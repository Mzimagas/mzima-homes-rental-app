/**
 * Service for subdivision management operations
 */

import supabase from '../supabase-client'
import { 
  Property, 
  SubdivisionItem, 
  SubdivisionPlot, 
  SubdivisionFormData,
  PlotFormData 
} from '../../types/subdivision'
import { isTableNotFoundError, getChangedFields, hectaresToSqm, toAcres } from '../utils/subdivision'
import { SubdivisionHistoryService } from './subdivision-history'

export class SubdivisionService {
  /**
   * Check if subdivision tables exist
   */
  static async checkTablesExist(): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('property_subdivisions')
        .select('id')
        .limit(1)
      
      return !error
    } catch (error) {
      return !isTableNotFoundError(error)
    }
  }

  /**
   * Load all subdivisions with property details
   */
  static async loadSubdivisions(): Promise<SubdivisionItem[]> {
    const { data, error } = await supabase
      .from('property_subdivisions')
      .select(`
        *,
        properties (
          id,
          name,
          physical_address,
          property_type,
          total_area_sqm,
          total_area_acres,
          lifecycle_status,
          subdivision_status,
          lat,
          lng,
          expected_rental_income_kes,
          purchase_completion_date,
          subdivision_date
        )
      `)
      .order('created_at', { ascending: false })

    if (error) {
      if (isTableNotFoundError(error)) {
        throw new Error('TABLES_NOT_FOUND')
      }
      throw error
    }

    return data || []
  }

  /**
   * Load plots for a specific subdivision
   */
  static async loadSubdivisionPlots(subdivisionId: string): Promise<SubdivisionPlot[]> {
    const { data, error } = await supabase
      .from('subdivision_plots')
      .select('*')
      .eq('subdivision_id', subdivisionId)
      .order('plot_number', { ascending: true })

    if (error) throw error
    return data || []
  }

  /**
   * Create a new subdivision
   */
  static async createSubdivision(
    propertyId: string, 
    formData: SubdivisionFormData
  ): Promise<SubdivisionItem> {
    const subdivisionData = {
      original_property_id: propertyId,
      subdivision_name: formData.subdivisionName,
      total_plots_planned: formData.totalPlotsPlanned,
      total_plots_created: 0,
      subdivision_status: 'planned',
      target_completion_date: formData.targetCompletionDate,
      surveyor_name: formData.surveyorName,
      surveyor_contact: formData.surveyorContact,
      approval_authority: formData.approvalAuthority || null,
      survey_cost_kes: formData.surveyCost,
      approval_fees_kes: formData.approvalFees || null,
      expected_plot_value_kes: formData.expectedPlotValue,
      subdivision_notes: formData.subdivisionNotes || null,
    }

    const { data, error } = await supabase
      .from('property_subdivisions')
      .insert(subdivisionData)
      .select()
      .single()

    if (error) throw error

    // Create auto-generated plots
    await this.createAutoGeneratedPlots(data.id, formData.totalPlotsPlanned)

    return data
  }

  /**
   * Update an existing subdivision
   */
  static async updateSubdivision(
    subdivisionId: string,
    formData: SubdivisionFormData,
    originalData: SubdivisionItem
  ): Promise<SubdivisionItem> {
    const updateData = {
      subdivision_name: formData.subdivisionName,
      total_plots_planned: formData.totalPlotsPlanned,
      target_completion_date: formData.targetCompletionDate,
      surveyor_name: formData.surveyorName,
      surveyor_contact: formData.surveyorContact,
      approval_authority: formData.approvalAuthority || null,
      survey_cost_kes: formData.surveyCost,
      approval_fees_kes: formData.approvalFees || null,
      expected_plot_value_kes: formData.expectedPlotValue,
      subdivision_notes: formData.subdivisionNotes || null,
      updated_at: new Date().toISOString(),
    }

    // Track changes for history
    const { hasChanges, changes, changedFields } = getChangedFields(originalData, updateData)

    if (hasChanges) {
      // Record history
      try {
        await SubdivisionHistoryService.recordPlanModification(
          subdivisionId,
          originalData.original_property_id,
          {
            previous_values: originalData,
            new_values: changes,
            updated_fields: changedFields.filter(field => field !== 'updated_at'),
          }
        )
      } catch (historyError) {
        console.warn('Failed to record subdivision history:', historyError)
      }
    }

    const { data, error } = await supabase
      .from('property_subdivisions')
      .update(updateData)
      .eq('id', subdivisionId)
      .select()
      .single()

    if (error) throw error
    return data
  }

  /**
   * Create auto-generated plots for a subdivision
   */
  private static async createAutoGeneratedPlots(
    subdivisionId: string, 
    totalPlots: number
  ): Promise<void> {
    const plots = Array.from({ length: totalPlots }, (_, index) => ({
      subdivision_id: subdivisionId,
      plot_number: `${index + 1}`,
      plot_size_sqm: hectaresToSqm(0.045), // Default 0.045 hectares
      plot_size_acres: toAcres(hectaresToSqm(0.045)),
      estimated_value_kes: null,
      plot_status: 'PLANNED',
      plot_notes: 'Auto-generated plot - please update size and details',
    }))

    const { error } = await supabase
      .from('subdivision_plots')
      .insert(plots)

    if (error) throw error
  }

  /**
   * Create or update a plot
   */
  static async upsertPlot(
    subdivisionId: string,
    plotData: PlotFormData,
    plotId?: string
  ): Promise<SubdivisionPlot> {
    const data = {
      subdivision_id: subdivisionId,
      plot_number: plotData.plotNumber,
      plot_size_sqm: plotData.plotSizeSqm,
      plot_size_acres: toAcres(plotData.plotSizeSqm),
      estimated_value_kes: plotData.estimatedValue || null,
      plot_notes: plotData.plotNotes || null,
      plot_status: 'PLANNED',
      updated_at: new Date().toISOString(),
    }

    if (plotId) {
      // Update existing plot
      const { data: updatedPlot, error } = await supabase
        .from('subdivision_plots')
        .update(data)
        .eq('id', plotId)
        .select()
        .single()

      if (error) throw error
      return updatedPlot
    } else {
      // Create new plot
      const { data: newPlot, error } = await supabase
        .from('subdivision_plots')
        .insert(data)
        .select()
        .single()

      if (error) throw error
      return newPlot
    }
  }

  /**
   * Delete a plot
   */
  static async deletePlot(plotId: string): Promise<void> {
    const { error } = await supabase
      .from('subdivision_plots')
      .delete()
      .eq('id', plotId)

    if (error) throw error
  }

  /**
   * Convert plot to property
   */
  static async convertPlotToProperty(plot: SubdivisionPlot): Promise<string> {
    // This would implement the plot to property conversion logic
    // For now, we'll just update the plot status
    const { error } = await supabase
      .from('subdivision_plots')
      .update({ 
        plot_status: 'PROPERTY_CREATED',
        updated_at: new Date().toISOString()
      })
      .eq('id', plot.id)

    if (error) throw error
    
    // Return a mock property ID for now
    return `property_${plot.id}`
  }

  /**
   * Revert property back to plot
   */
  static async revertPropertyToPlot(plot: SubdivisionPlot): Promise<void> {
    const { error } = await supabase
      .from('subdivision_plots')
      .update({ 
        plot_status: 'PLANNED',
        created_property_id: null,
        updated_at: new Date().toISOString()
      })
      .eq('id', plot.id)

    if (error) throw error
  }
}
